---
description: 将自然语言描述转化为结构化、可测试的规格说明书 (Spec)，并强制利用 RAG 知识库证据提升领域正确性。
handoffs:
  - label: 制定技术方案
    agent: speckit.plan
    prompt: 基于 spec.md 中的测试契约制定技术实现计划
---

## 执行代理要求（强制）

本命令**必须由子代理 `specification_agent` 执行**，主线程不得直接撰写 spec。

执行规则：
1. 立即将本命令的全部工作委派给 `specification_agent`
2. 必须严格遵守本命令文档中的 RAG 证据注入要求（knowledge-pack → Digest → Evidence Trace）
3. 主线程只负责输出最终产物路径与完成情况
4. 若未成功委派，则必须停止并改为委派后再继续

## User Input

```text
$ARGUMENTS
```

## Preflight Checklist (前置检查)

### 0. Knowledge Pack（RAG 知识库强制注入）

在生成 spec 之前，**必须**先生成并读取检索上下文包（Knowledge Pack），否则不得开始写规范。

#### 0.1 生成 Knowledge Pack

执行命令：

- `myspec kb pack "$ARGUMENTS" --topk 8`

#### 0.2 读取 Knowledge Pack

必须读取（Read）：

- `.myspec/context/knowledge-pack.md`

#### 0.3 证据标号规则（强制）

Knowledge Pack 中的证据条目按出现顺序编号：

- 第 1 条证据 => **[E1]**
- 第 2 条证据 => **[E2]**
- ...
- 第 N 条证据 => **[EN]**

在后续编写 spec 时，引用证据只能使用 **[E1] ~ [EN]** 这样的标签格式。

#### 0.4 领域证据摘要（Digest）必须先写出来（强制）

在正式撰写 spec.md 之前，必须先完成一个“领域证据摘要”，规则如下：

- 最多 **5~12** 条要点（bullet）
- 每条要点必须带引用标签，例如：`... [E1]`
- 只允许写“与当前功能直接相关”的领域规则/流程/约束
- **禁止**把实现细节写进摘要（不涉及语言、框架、API、数据库）

> 如果 Knowledge Pack 没有任何证据（空结果），必须在摘要位置写明：
>  “知识库未检索到相关证据，本规范仅基于用户输入生成。”



**IMPORTANT**: 在执行任何生成动作前，必须按顺序完成以下检查：

1. **Input Analysis**:
   - 用户描述 (`$ARGUMENTS`) 是否包含足够的核心价值？
   - 如果输入仅为 1-2 个单词（如 "Login"），**拒绝执行**，并提示用户提供完整场景。

2. **Branching Strategy Calculation (计算分支策略)**: 在调用创建脚本之前，你必须先计算出正确的编号和名称：

   a. **Generate Short Name**:
   - 提取关键词，生成 2-4 个单词的短名 (kebab-case)。
   - 保留技术术语 (如 "oauth2", "api")。
   - 示例: "Add user authentication" -> "user-auth"

   b. **Determine Next Number**:
   - 执行 `git fetch --all --prune` 确保信息最新。
   - 检查以下所有来源中匹配 `[0-9]+-<short-name>` 模式的最大编号：
     1. 远程分支: `git ls-remote --heads origin`
     2. 本地分支: `git branch`
     3. 本地目录: `ls specs/`
   - 找到最大编号 N，新分支编号为 N+1 (若无则为 1)。

   c. **Execute Script**:
   - 使用计算出的参数调用脚本：
   - `scripts/create-new-feature.* --json --number <N+1> --short-name "<short-name>" "$ARGUMENTS"`

3. 加载 `templates/spec-template.md` 以了解所需的章节结构。

4. 重要事项：
   - JSON 结果将在终端中输出，请务必引用它以获取你需要的实际内容。
   - JSON 输出将包含 `BRANCH_NAME` 和 `SPEC_FILE` 路径。



## 强制输出规范（必须遵守）

在生成 `spec.md` 时，必须满足以下硬性要求（否则视为失败，不允许进入下一阶段）：

### A) Spec 必须包含「领域证据摘要（Digest）」章节

在 spec 中新增一个章节（如果模板没有该章节，也必须插入）：

```
## 领域证据摘要（来自知识库）

- ... [E1]
- ... [E2]
- ...
```

规则：

- 如果 Knowledge Pack 有证据：至少 **3 条**带引用要点
- 如果 Knowledge Pack 无证据：必须写明“未检索到证据”，并且后续内容仅基于用户输入（不要瞎补领域规则）

### B) 证据必须落地到 Spec 正文（不能只写在摘要里）

以下区域必须至少出现 1 个证据引用（只要 Knowledge Pack 非空）：

- 业务流程 / 状态流转（Workflow / State）
- 角色权限（谁能做什么）
- 校验规则 / 业务约束（Validation / Constraints）
- 异常与边界情况（Edge Cases）
- 验收标准 / 可测试契约（Acceptance Criteria / Scenarios）

### C) 禁止行为（强制）

- **禁止**凭空编造领域规则
   领域规则只能来自：
  1. 用户输入
  2. Knowledge Pack 证据（[E1]~[EN]）
- 如果必须做“证据之外的推断”，必须明确标注为假设：

```
> 假设（不在证据中）：......
> 风险：......
```

### D) Spec 末尾必须提供证据溯源（Evidence Trace）

在 spec 末尾新增：

```
## 证据溯源（Evidence Trace）
- [E1] <证据标题路径> — <source path>
- [E2] <证据标题路径> — <source path>
...
```



## Error Recovery

- 如果 Git 命令失败，尝试使用本地计算的编号降级执行。
- 如果用户描述存在逻辑矛盾或不清晰的地方，使用 `[NEEDS CLARIFICATION]` 标记在 Spec 中对应位置标记高亮。
- 如果 Knowledge Pack 为空：
  - 在“领域证据摘要”中明确写出“未检索到证据”
  - 规范正文不得出现任何“看起来像领域规则”的补充（除非用户明确提供）



## Execution Steps

**注意：模板中仅为格式定义，具体数量需要根据实际情况来安排（比如模板中定义了三个用户故事，但不是必须要三个，需要根据当前用户描述的实际情况来决定数量，其余如验收场景、功能需求、关键实体等的数量同理）。另外注意使用中文（前面提到的[NEEDS CLARIFICATION]标记除外）**

### 1. TDD Foundation & Domain Modeling

读取 `templates/spec-template.md`，根据用户描述开始填充内容：

- **Step 1: Define Domain Dictionary (领域词典)**
  - 分析用户描述，提取核心业务实体。
  - **强制动作**: 为每个实体指定全局唯一的 **Code Term (类名/变量名)**。
- **Step 1.5: 写入“领域证据摘要（Digest）”章节（强制）**
  - 基于 `.myspec/context/knowledge-pack.md` 先产出摘要要点
  - 每条要点必须带 [E1]~[EN] 引用标签
  - 摘要只写“领域事实/规则/约束”，不写实现方式

### 2. User Stories & Test Contracts (核心逻辑)

编写用户故事，遵循以下规则：

- **Structure**: 对每个Story设置优先级，按照优先级排序 (P1, P2, P3...)。
- **Priority Logic**: 必须填写 `Why this priority`，解释业务价值。
- **Scenarios**: 每个 Story 必须包含验收场景，且所有的验收场景加起来需要能完全覆盖这个Story的所有方面。
- **Automatic Tagging (自动打标)**: 你必须根据场景内容，自动打上以下 Tag：
  - **`@core`**: 核心业务路径，P1 级功能的快乐路径。
  - **`@happy-path`**: 符合预期的成功流程。
  - **`@error-handling`**: 输入非法、网络中断、数据缺失等异常流程。
  - **`@performance`**: 涉及大量数据或高并发的场景。
  - **`@security`**: 涉及权限、加密、隐私的场景。

**强制要求（证据落地）**：

- 如果某个用户故事涉及流程规则/审批规则/状态变化/权限边界，那么该 Story 或其 Scenarios 中必须引用至少 1 条证据（例如：[E1]）。
- 如果知识库证据与用户输入冲突，必须在 spec 中显式标注冲突点，并优先遵循用户输入，同时列出风险。

### 3. Comprehensive Requirements

- 填充文档的其余部分（并强制证据落地）：
  - **Edge Cases**: 思考边界条件（如：空状态、最大值、断网）。
    - 若 Edge Case 属于领域规则（例如审批失败回退、状态不可逆），必须引用证据（例如：[E1]）。
  - **Functional Requirements**: 从场景中反推的具体功能点。
    - 若功能点属于业务规则（角色权限、流程约束、状态变更条件），必须引用证据（例如：[E1]）。
  - **Non-Functional Requirements**: 根据具体场景推导出非功能性需求。
  - **Key Entities**: 如果涉及数据存储，定义实体及其关系。
    - 若实体字段/关系属于领域定义（例如资产状态枚举、审批记录结构），尽量引用证据（例如：[E1]）；如果证据不足则标注为“假设”。
  - **Success Criteria**: 定义可衡量的成功标准（非技术实现细节）。

### 4. Write

将上述的所有内容写入到文件 `SPEC_FILE`（即规范文档的路径`specs/<branch>/spec.md`）的对应章节。

同时，在 spec 文档末尾追加两个章节（如果模板没有，也必须追加）：

1. `## 证据溯源（Evidence Trace）`
2. `## 假设（不在证据中）`（仅当确实有假设时才写）



### 5. Quality Verification

完成初步规范撰写后，根据质量标准进行验证：

1.**创建规范质量检查清单**：使用检查清单模板结构，在规范文档的同级目录下生成一个清单文件`requirements.md`，包含以下验证项：

```markdown
# 规范质量检查清单：[功能名称]

**目的**：在进入规划阶段前，验证规范的完整性和质量
**创建日期**：[日期]
**功能**：[链接到 spec.md]

## 内容质量

- [ ] 没有实现细节（语言、框架、API）
- [ ] 聚焦于用户价值和业务需求
- [ ] 为非技术利益相关者编写
- [ ] 所有必填章节均已完成

## 需求完整性

- [ ] 没有遗留的 `[NEEDS CLARIFICATION]` 标记
- [ ] 需求可测试且明确无歧义
- [ ] 成功标准是可衡量的
- [ ] 成功标准是技术无关的（不包含实现细节）
- [ ] 所有验收场景均已定义
- [ ] 已识别边界情况
- [ ] 范围界定清晰
- [ ] 已识别依赖项和假设

## 功能就绪状态

- [ ] 所有功能需求都有明确的验收标准
- [ ] 用户场景覆盖了主要流程
- [ ] 功能满足“成功标准”中定义的可衡量结果
- [ ] 没有实现细节泄露到规范中

## 备注

- 标记为未完成的项目需要在执行 `/speckit.plan` 前更新规范
```

2.**执行验证检查**：对照检查清单的每一项审查规范：

- 对于每一项，判断其是否通过。
- 记录发现的具体问题（引用相关规范章节）。

  3.**处理验证结果**：

- **如果所有项都通过**：标记检查清单为完成，并继续执行步骤 6。

- **如果有项失败（不包括 [NEEDS CLARIFICATION]）**：
  1.  列出失败的项及其具体问题。
  2.  **更新规范以解决每个问题。**
  3.  重新运行验证，直到所有项都通过（**最多迭代 3 次**）。
  4.  如果 3 次迭代后仍然失败，在检查清单的备注中记录遗留问题并警告用户。

- **如果遗留有 [NEEDS CLARIFICATION] 标记**：
  1. 从规范中提取所有 [NEEDS CLARIFICATION] 标记。

  2. **数量限制检查**：如果超过 3 个标记，只保留 3 个最关键（按范围/安全/用户体验影响）的，其余部分做出有依据的推断。

  3. 对于每个需要澄清的地方（最多 3 个），以下列格式向用户呈现选项：

     ```markdown
     ## 问题 [N]：[主题]

     **上下文**：[引用相关规范章节]

     **我们需要知道**：[来自“NEEDS CLARIFICATION”标记的具体问题]

     **建议的答案**：

     | 选项   | 答案             | 影响                     |
     | ------ | ---------------- | ------------------------ |
     | A      | [第一个建议答案] | [这对功能意味着什么]     |
     | B      | [第二个建议答案] | [这对功能意味着什么]     |
     | C      | [第三个建议答案] | [这对功能意味着什么]     |
     | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |

     **您的选择**：_[等待用户回应]_
     ```

  4. **关键点 - 表格格式**：确保 Markdown 表格格式正确：
     - 使用一致的间距和对齐的竖线。
     - 每个单元格内容周围应有空格：`| 内容 |` 而不是 `|内容|`。
     - 表头分隔符必须有至少 3 个短横线：`|--------|`。
     - 测试表格在 Markdown 预览中能正确渲染。

  5. 按顺序编号问题（Q1, Q2, Q3 - 最多总共 3 个）。

  6. 在等待回应之前，一次性呈现所有问题。

  7. 等待用户回应他们对所有问题的选择（例如，“Q1: A, Q2: 自定义 - [详情], Q3: B”）。

  8. 用用户选择或提供的答案替换每个 `[需要澄清]` 标记，更新规范。

  9. 所有澄清解决后，重新运行验证。

  4.**更新检查清单**：每次验证迭代后，更新检查清单文件，记录当前通过/失败的状态。

### 6.Report

报告完成情况，包括分支名称、规范文件路径、检查清单结果。

## 快速指南

- 聚焦于用户**需要什么**以及**为什么需要**。
- 避免**如何实现**（不涉及技术栈、API、代码结构）。
- 为业务利益相关者编写，而不是为开发者。
- **不要**在规范内嵌入任何检查清单。那将是另一个单独的命令。

### 关于 AI 生成规范

当根据用户提示创建此规范时：

1. **进行有依据的推断**：利用上下文、行业标准和常见模式来填补空白。
2. **限制澄清需求**：最多使用 3 个 [NEEDS CLARIFICATION] 标记 —— 仅用于对以下方面有重大影响的关键决策：
   - 显著影响功能范围或用户体验。
   - 存在多种合理但影响不同的解释。
   - 没有任何合理的默认选项。
3. **优先处理澄清需求**：范围 > 安全/隐私 > 用户体验 > 技术细节。
4. **像测试人员一样思考**：每个模糊的需求都应该无法通过“可测试且明确无歧义”的检查项。
5. **通常需要澄清的领域**（仅在不存在合理默认值时）：
   - 功能范围和边界（包含/排除特定的用例）。
   - 用户类型和权限（如果可能存在多种冲突的解释）。
   - 安全/合规要求（当具有法律/财务上的重要意义时）。

**合理默认值的示例**（无需询问）：

- 数据保留：该领域内行业标准的做法。
- 性能目标：除非另有规定，遵循标准 Web/移动应用期望。
- 错误处理：用户友好的提示信息与适当的回退机制。
- 认证方法：对于 Web 应用，采用基于会话的标准方式或 OAuth2。
- 集成模式：除非另有规定，采用 RESTful API。

### 成功标准指南

成功标准必须：

1. **可衡量**：包含具体的指标（时间、百分比、数量、比率）。
2. **技术无关**：不提及框架、语言、数据库或工具。
3. **用户导向**：从用户/业务角度描述结果，而非系统内部。
4. **可验证**：可以在不了解实现细节的情况下进行测试/验证。

**好的示例**：

- “用户能在 3 分钟内完成结账。”
- “系统支持 10，000 名并发用户。”
- “95% 的搜索能在 1 秒内返回结果。”
- “任务完成率提高 40%。”

**不好的示例**（聚焦于实现）：

- “API 响应时间低于 200 毫秒”（过于技术性，应使用“用户能即时看到结果”）。
- “数据库能处理 1000 TPS”（实现细节，应使用面向用户的指标）。
- “React 组件渲染高效”（框架特定）。
- “Redis 缓存命中率高于 80%”（技术特定）。
