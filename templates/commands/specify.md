---
description: Create or update the feature specification from a natural language feature description.
handoffs: 
  - label: Build Technical Plan
    agent: speckit.plan
    prompt: Create a plan for the spec. I am building with...
  - label: Clarify Spec Requirements
    agent: speckit.clarify
    prompt: Clarify specification requirements
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## User Input

```text
$ARGUMENTS
```

如果用户输入非空，在继续之前**必须**先处理其内容。

## Outline

用户在触发消息中 `/speckit.specify` 之后输入的文本**就是**功能描述。请始终假设在当前对话中可以获得此信息，即使下方字面显示了 `{ARGS}`。除非用户输入了空命令，否则不要要求用户重复描述。

根据该功能描述，请按以下步骤操作：

1.  **生成简洁的短名称（2-4个单词）用于分支**：
    *   分析功能描述，提取最有意义的关键词。
    *   创建一个2-4个单词的短名称，能够抓住功能的精髓。
    *   尽可能使用“动作-名词”格式（例如，“add-user-auth”、“fix-payment-bug”）。
    *   保留技术术语和缩写（如 OAuth2, API, JWT 等）。
    *   保持简洁，但要有足够的描述性，以便一眼理解功能。
    *   示例：
        *   “我想添加用户认证” → “user-auth”
        *   “为 API 实现 OAuth2 集成” → “oauth2-api-integration”
        *   “创建一个分析仪表板” → “analytics-dashboard”
        *   “修复支付处理超时错误” → “fix-payment-timeout”

2.  **在创建新分支前检查现有分支**：

    a. 首先，获取所有远程分支，确保信息是最新的：
       ```bash
       git fetch --all --prune
       ```

    b. 根据短名称，在所有来源中查找最高的功能编号：
        *   远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
        *   本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
        *   规范目录：检查是否存在匹配 `specs/[0-9]+-<short-name>` 的目录

    c. 确定下一个可用的编号：
        *   从上述三个来源中提取所有数字
        *   找到最大的数字 N
        *   使用 N+1 作为新分支的编号

    d. 使用计算出的编号和短名称运行脚本 `{SCRIPT}`：
        *   传递 `--number N+1` 和 `--short-name "你的短名称"` 以及功能描述
        *   Bash 示例：`{SCRIPT} --json --number 5 --short-name "user-auth" "添加用户认证"`
        *   PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "添加用户认证"`

    **重要提示**：
    *   检查所有三个来源（远程分支、本地分支、规范目录）以找到最大编号。
    *   只匹配具有完全相同的短名称模式的分支/目录。
    *   如果未找到具有此短名称的现有分支/目录，则从编号 1 开始。
    *   每个功能**只能运行此脚本一次**。
    *   JSON 结果将在终端中输出，请务必引用它以获取你需要的实际内容。
    *   JSON 输出将包含 `BRANCH_NAME` 和 `SPEC_FILE` 路径。
    *   对于参数中的单引号（如 “I‘m Groot”），请使用转义语法，例如 `'I'\''m Groot'`（或尽可能使用双引号：`"I'm Groot"`）。

3.  加载 `templates/spec-template.md` 以了解所需的章节结构。

4.  遵循以下执行流程：

    1.  **解析用户输入**
        如果为空：报错“未提供功能描述”。
    2.  **从描述中提取关键概念**
        识别：参与者、动作、数据、约束条件。
    3.  **处理不明确的部分**
        *   根据上下文和行业标准做出有依据的推断。
        *   仅在以下情况下使用 `[需要澄清：具体问题]` 标记：
            *   该选择会显著影响功能范围或用户体验。
            *   存在多种合理的解释，且各自影响不同。
            *   不存在合理的默认选项。
        *   **限制：最多使用 3 个 `[需要澄清]` 标记**。
        *   按影响程度优先级排序澄清需求：范围 > 安全/隐私 > 用户体验 > 技术细节。
    4.  **填写“用户场景与测试”章节**
        如果无法确定清晰的用户流程：报错“无法确定用户场景”。
    5.  **生成“功能需求”**
        每个需求必须是可测试的。
        对于未指定的细节，使用合理的默认值（在“假设”章节中记录这些假设）。
    6.  **定义“成功标准”**
        创建可衡量的、与技术无关的结果。
        包括量化指标（时间、性能、容量）和定性衡量标准（用户满意度、任务完成率）。
        每个标准必须可以在不了解实现细节的情况下进行验证。
    7.  **识别“关键实体”（如果涉及数据）**
    8.  **返回结果**：成功（规范已准备好进入规划阶段）。

5.  使用模板结构，将占位符替换为从功能描述中推导出的具体细节，同时保持章节顺序和标题不变，将规范写入 `SPEC_FILE`。

6.  **规范质量验证**：完成初步规范撰写后，根据质量标准进行验证：

    a.  **创建规范质量检查清单**：使用检查清单模板结构，在 `FEATURE_DIR/checklists/requirements.md` 处生成一个清单文件，包含以下验证项：
        ```markdown
        # 规范质量检查清单：[功能名称]

        **目的**：在进入规划阶段前，验证规范的完整性和质量
        **创建日期**：[日期]
        **功能**：[链接到 spec.md]
    
        ## 内容质量
    
        - [ ] 没有实现细节（语言、框架、API）
        - [ ] 聚焦于用户价值和业务需求
        - [ ] 为非技术利益相关者编写
        - [ ] 所有必填章节均已完成
    
        ## 需求完整性
    
        - [ ] 没有遗留的 `[需要澄清]` 标记
        - [ ] 需求可测试且明确无歧义
        - [ ] 成功标准是可衡量的
        - [ ] 成功标准是技术无关的（不包含实现细节）
        - [ ] 所有验收场景均已定义
        - [ ] 已识别边界情况
        - [ ] 范围界定清晰
        - [ ] 已识别依赖项和假设
    
        ## 功能就绪状态
    
        - [ ] 所有功能需求都有明确的验收标准
        - [ ] 用户场景覆盖了主要流程
        - [ ] 功能满足“成功标准”中定义的可衡量结果
        - [ ] 没有实现细节泄露到规范中
    
        ## 备注
    
        - 标记为未完成的项目需要在执行 `/speckit.clarify` 或 `/speckit.plan` 前更新规范
        ```

    b.  **执行验证检查**：对照检查清单的每一项审查规范：
        *   对于每一项，判断其是否通过。
        *   记录发现的具体问题（引用相关规范章节）。

    c.  **处理验证结果**：
        *   **如果所有项都通过**：标记检查清单为完成，并继续执行步骤 6。
        *   **如果有项失败（不包括 `[需要澄清]`）**：
            1.  列出失败的项及其具体问题。
            2.  更新规范以解决每个问题。
            3.  重新运行验证，直到所有项都通过（最多迭代 3 次）。
            4.  如果 3 次迭代后仍然失败，在检查清单的备注中记录遗留问题并警告用户。
        *   **如果遗留有 `[需要澄清]` 标记**：
            1.  从规范中提取所有 `[需要澄清：...]` 标记。
            2.  **数量限制检查**：如果超过 3 个标记，只保留 3 个最关键（按范围/安全/用户体验影响）的，其余部分做出有依据的推断。
            3.  对于每个需要澄清的地方（最多 3 个），以下列格式向用户呈现选项：
                ```markdown
                ## 问题 [N]：[主题]

                **上下文**：[引用相关规范章节]
    
                **我们需要知道**：[来自“需要澄清”标记的具体问题]
    
                **建议的答案**：
    
                | 选项 | 答案 | 影响 |
                |------|------|------|
                | A    | [第一个建议答案] | [这对功能意味着什么] |
                | B    | [第二个建议答案] | [这对功能意味着什么] |
                | C    | [第三个建议答案] | [这对功能意味着什么] |
                | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |
    
                **您的选择**：_[等待用户回应]_
                ```
            4.  **关键点 - 表格格式**：确保 Markdown 表格格式正确：
                *   使用一致的间距和对齐的竖线。
                *   每个单元格内容周围应有空格：`| 内容 |` 而不是 `|内容|`。
                *   表头分隔符必须有至少 3 个短横线：`|--------|`。
                *   测试表格在 Markdown 预览中能正确渲染。
            5.  按顺序编号问题（Q1, Q2, Q3 - 最多总共 3 个）。
            6.  在等待回应之前，一次性呈现所有问题。
            7.  等待用户回应他们对所有问题的选择（例如，“Q1: A, Q2: 自定义 - [详情], Q3: B”）。
            8.  用用户选择或提供的答案替换每个 `[需要澄清]` 标记，更新规范。
            9.  所有澄清解决后，重新运行验证。

    d.  **更新检查清单**：每次验证迭代后，更新检查清单文件，记录当前通过/失败的状态。

7.  报告完成情况，包括分支名称、规范文件路径、检查清单结果，以及进入下一阶段（`/speckit.clarify` 或 `/speckit.plan`）的准备状态。

**注意**：脚本会在写入规范之前，创建并检出新的分支，并初始化规范文件。

## 通用指导原则

## 快速指南

*   聚焦于用户**需要什么**以及**为什么需要**。
*   避免**如何实现**（不涉及技术栈、API、代码结构）。
*   为业务利益相关者编写，而不是为开发者。
*   **不要**在规范内嵌入任何检查清单。那将是另一个单独的命令。

### 章节要求

*   **必填章节**：每个功能都必须完成。
*   **可选章节**：仅在与功能相关时才包括。
*   当某个章节不适用时，请完全移除它（不要留作“不适用”）。

### 关于 AI 生成规范

当根据用户提示创建此规范时：

1.  **进行有依据的推断**：利用上下文、行业标准和常见模式来填补空白。
2.  **记录假设**：在“假设”章节中记录合理的默认值。
3.  **限制澄清需求**：最多使用 3 个 `[需要澄清]` 标记 —— 仅用于对以下方面有重大影响的关键决策：
    *   显著影响功能范围或用户体验。
    *   存在多种合理但影响不同的解释。
    *   没有任何合理的默认选项。
4.  **优先处理澄清需求**：范围 > 安全/隐私 > 用户体验 > 技术细节。
5.  **像测试人员一样思考**：每个模糊的需求都应该无法通过“可测试且明确无歧义”的检查项。
6.  **通常需要澄清的领域**（仅在不存在合理默认值时）：
    *   功能范围和边界（包含/排除特定的用例）。
    *   用户类型和权限（如果可能存在多种冲突的解释）。
    *   安全/合规要求（当具有法律/财务上的重要意义时）。

**合理默认值的示例**（无需询问）：

*   数据保留：该领域内行业标准的做法。
*   性能目标：除非另有规定，遵循标准 Web/移动应用期望。
*   错误处理：用户友好的提示信息与适当的回退机制。
*   认证方法：对于 Web 应用，采用基于会话的标准方式或 OAuth2。
*   集成模式：除非另有规定，采用 RESTful API。

### 成功标准指南

成功标准必须：

1.  **可衡量**：包含具体的指标（时间、百分比、数量、比率）。
2.  **技术无关**：不提及框架、语言、数据库或工具。
3.  **用户导向**：从用户/业务角度描述结果，而非系统内部。
4.  **可验证**：可以在不了解实现细节的情况下进行测试/验证。

**好的示例**：

*   “用户能在 3 分钟内完成结账。”
*   “系统支持 10，000 名并发用户。”
*   “95% 的搜索能在 1 秒内返回结果。”
*   “任务完成率提高 40%。”

**不好的示例**（聚焦于实现）：

*   “API 响应时间低于 200 毫秒”（过于技术性，应使用“用户能即时看到结果”）。
*   “数据库能处理 1000 TPS”（实现细节，应使用面向用户的指标）。
*   “React 组件渲染高效”（框架特定）。
*   “Redis 缓存命中率高于 80%”（技术特定）。

[文件内容结束]
