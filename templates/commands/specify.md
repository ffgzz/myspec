---
description: 将自然语言描述转化为结构化、可测试的规格说明书 (Spec)。
handoffs:
  - label: 制定技术方案
    agent: speckit.plan
    prompt: 基于 spec.md 中的测试契约制定技术实现计划
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## User Input

```text
$ARGUMENTS
```

## Preflight Checklist (前置检查)

**IMPORTANT**: 在执行任何生成动作前，必须按顺序完成以下检查：

1. **Input Analysis**:

   - 用户描述 (`$ARGUMENTS`) 是否包含足够的核心价值？
   - 如果输入仅为 1-2 个单词（如 "Login"），**拒绝执行**，并提示用户提供完整场景。

2. **Branching Strategy Calculation (计算分支策略)**: 在调用创建脚本之前，你必须先计算出正确的编号和名称：

   a. **Generate Short Name**:

   - 提取关键词，生成 2-4 个单词的短名 (kebab-case)。
   - 保留技术术语 (如 "oauth2", "api")。
   - 示例: "Add user authentication" -> "user-auth"

   b. **Determine Next Number**:

   - 执行 `git fetch --all --prune` 确保信息最新。
   - 检查以下所有来源中匹配 `[0-9]+-<short-name>` 模式的最大编号：
     1. 远程分支: `git ls-remote --heads origin`
     2. 本地分支: `git branch`
     3. 本地目录: `ls specs/`
   - 找到最大编号 N，新分支编号为 N+1 (若无则为 1)。

   c. **Execute Script**:

   - 使用计算出的参数调用脚本：
   - `scripts/bash/create-new-feature.sh --json --number <N+1> --short-name "<short-name>" "$ARGUMENTS"`

3. 加载 `templates/spec-template.md` 以了解所需的章节结构。

4. 重要事项：

   - JSON 结果将在终端中输出，请务必引用它以获取你需要的实际内容。
   - JSON 输出将包含 `BRANCH_NAME` 和 `SPEC_FILE` 路径。

## Error Recovery

- 如果 Git 命令失败，尝试使用本地计算的编号降级执行。
- 如果用户描述存在逻辑矛盾或不清晰的地方，使用 `[NEEDS CLARIFICATION]` 标记在 Spec 中对应位置标记高亮。

## Execution Steps

**注意：模板中仅为格式定义，具体数量需要根据实际情况来安排（比如模板中定义了三个用户故事，但不是必须要三个，需要根据当前用户描述的实际情况来决定数量，其余如验收场景、功能需求、关键实体等的数量同理）。另外注意使用中文（前面提到的[NEEDS CLARIFICATION]标记除外）**

### 1. TDD Foundation & Domain Modeling

读取 `templates/spec-template.md`，根据用户描述开始填充内容：

- **Step 1: Define Domain Dictionary (领域词典)**
  - 分析用户描述，提取核心业务实体。
  - **强制动作**: 为每个实体指定全局唯一的 **Code Term (类名/变量名)**。

### 2. User Stories & Test Contracts (核心逻辑)

编写用户故事，遵循以下规则：

- **Structure**: 对每个Story设置优先级，按照优先级排序 (P1, P2, P3...)。
- **Priority Logic**: 必须填写 `Why this priority`，解释业务价值。
- **Scenarios**: 每个 Story 必须包含验收场景，且所有的验收场景加起来需要能完全覆盖这个Story的所有方面。
- **Automatic Tagging (自动打标)**: 你必须根据场景内容，自动打上以下 Tag：
  - **`@core`**: 核心业务路径，P1 级功能的快乐路径。
  - **`@happy-path`**: 符合预期的成功流程。
  - **`@error-handling`**: 输入非法、网络中断、数据缺失等异常流程。
  - **`@performance`**: 涉及大量数据或高并发的场景。
  - **`@security`**: 涉及权限、加密、隐私的场景。

### 3. Comprehensive Requirements

填充文档的其余部分：

- **Edge Cases**: 思考边界条件（如：空状态、最大值、断网）。
- **Functional Requirements**: 从场景中反推的具体功能点。
- **Non-Functional Requirements**: 根据具体场景推导出非功能性需求。
- **Key Entities**: 如果涉及数据存储，定义实体及其关系。
- **Success Criteria**: 定义可衡量的成功标准（非技术实现细节）。

### 4. Write

将上述的所有内容写入到文件 `SPEC_FILE`（即规范文档的路径`specs/<branch>/spec.md`）的对应章节。

### 5. Quality Verification

完成初步规范撰写后，根据质量标准进行验证：

1.**创建规范质量检查清单**：使用检查清单模板结构，在规范文档的同级目录下生成一个清单文件`requirements.md`，包含以下验证项：

```markdown
# 规范质量检查清单：[功能名称]
**目的**：在进入规划阶段前，验证规范的完整性和质量
**创建日期**：[日期]
**功能**：[链接到 spec.md]

## 内容质量

- [ ] 没有实现细节（语言、框架、API）
- [ ] 聚焦于用户价值和业务需求
- [ ] 为非技术利益相关者编写
- [ ] 所有必填章节均已完成

## 需求完整性

- [ ] 没有遗留的 `[NEEDS CLARIFICATION]` 标记
- [ ] 需求可测试且明确无歧义
- [ ] 成功标准是可衡量的
- [ ] 成功标准是技术无关的（不包含实现细节）
- [ ] 所有验收场景均已定义
- [ ] 已识别边界情况
- [ ] 范围界定清晰
- [ ] 已识别依赖项和假设

## 功能就绪状态

- [ ] 所有功能需求都有明确的验收标准
- [ ] 用户场景覆盖了主要流程
- [ ] 功能满足“成功标准”中定义的可衡量结果
- [ ] 没有实现细节泄露到规范中

## 备注

- 标记为未完成的项目需要在执行 `/speckit.plan` 前更新规范
```

2.**执行验证检查**：对照检查清单的每一项审查规范：

* 对于每一项，判断其是否通过。
* 记录发现的具体问题（引用相关规范章节）。

3.**处理验证结果**：

* **如果所有项都通过**：标记检查清单为完成，并继续执行步骤 6。

* **如果有项失败（不包括 [NEEDS CLARIFICATION]）**：

  1.  列出失败的项及其具体问题。
  2. **更新规范以解决每个问题。**
  3. 重新运行验证，直到所有项都通过（**最多迭代 3 次**）。
  4. 如果 3 次迭代后仍然失败，在检查清单的备注中记录遗留问题并警告用户。

* **如果遗留有 [NEEDS CLARIFICATION] 标记**：

  1. 从规范中提取所有 [NEEDS CLARIFICATION] 标记。

  2. **数量限制检查**：如果超过 3 个标记，只保留 3 个最关键（按范围/安全/用户体验影响）的，其余部分做出有依据的推断。

  3. 对于每个需要澄清的地方（最多 3 个），以下列格式向用户呈现选项：

     ```markdown
     ## 问题 [N]：[主题]
     
     **上下文**：[引用相关规范章节]
     
     **我们需要知道**：[来自“NEEDS CLARIFICATION”标记的具体问题]
     
     **建议的答案**：
     
     | 选项 | 答案 | 影响 |
     |------|------|------|
     | A    | [第一个建议答案] | [这对功能意味着什么] |
     | B    | [第二个建议答案] | [这对功能意味着什么] |
     | C    | [第三个建议答案] | [这对功能意味着什么] |
     | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |
     
     **您的选择**：_[等待用户回应]_
     ```

  4. **关键点 - 表格格式**：确保 Markdown 表格格式正确：

     *   使用一致的间距和对齐的竖线。
     *   每个单元格内容周围应有空格：`| 内容 |` 而不是 `|内容|`。
     *   表头分隔符必须有至少 3 个短横线：`|--------|`。
     *   测试表格在 Markdown 预览中能正确渲染。

  5. 按顺序编号问题（Q1, Q2, Q3 - 最多总共 3 个）。

  6. 在等待回应之前，一次性呈现所有问题。

  7. 等待用户回应他们对所有问题的选择（例如，“Q1: A, Q2: 自定义 - [详情], Q3: B”）。

  8. 用用户选择或提供的答案替换每个 `[需要澄清]` 标记，更新规范。

  9. 所有澄清解决后，重新运行验证。

4.**更新检查清单**：每次验证迭代后，更新检查清单文件，记录当前通过/失败的状态。

###  6.Report

报告完成情况，包括分支名称、规范文件路径、检查清单结果。



## 快速指南

- 聚焦于用户**需要什么**以及**为什么需要**。
- 避免**如何实现**（不涉及技术栈、API、代码结构）。
- 为业务利益相关者编写，而不是为开发者。
- **不要**在规范内嵌入任何检查清单。那将是另一个单独的命令。



### 关于 AI 生成规范

当根据用户提示创建此规范时：

1. **进行有依据的推断**：利用上下文、行业标准和常见模式来填补空白。
2. **限制澄清需求**：最多使用 3 个 [NEEDS CLARIFICATION] 标记 —— 仅用于对以下方面有重大影响的关键决策：
   - 显著影响功能范围或用户体验。
   - 存在多种合理但影响不同的解释。
   - 没有任何合理的默认选项。
3. **优先处理澄清需求**：范围 > 安全/隐私 > 用户体验 > 技术细节。
4. **像测试人员一样思考**：每个模糊的需求都应该无法通过“可测试且明确无歧义”的检查项。
5. **通常需要澄清的领域**（仅在不存在合理默认值时）：
   - 功能范围和边界（包含/排除特定的用例）。
   - 用户类型和权限（如果可能存在多种冲突的解释）。
   - 安全/合规要求（当具有法律/财务上的重要意义时）。

**合理默认值的示例**（无需询问）：

- 数据保留：该领域内行业标准的做法。
- 性能目标：除非另有规定，遵循标准 Web/移动应用期望。
- 错误处理：用户友好的提示信息与适当的回退机制。
- 认证方法：对于 Web 应用，采用基于会话的标准方式或 OAuth2。
- 集成模式：除非另有规定，采用 RESTful API。



### 成功标准指南

成功标准必须：

1. **可衡量**：包含具体的指标（时间、百分比、数量、比率）。
2. **技术无关**：不提及框架、语言、数据库或工具。
3. **用户导向**：从用户/业务角度描述结果，而非系统内部。
4. **可验证**：可以在不了解实现细节的情况下进行测试/验证。

**好的示例**：

- “用户能在 3 分钟内完成结账。”
- “系统支持 10，000 名并发用户。”
- “95% 的搜索能在 1 秒内返回结果。”
- “任务完成率提高 40%。”

**不好的示例**（聚焦于实现）：

- “API 响应时间低于 200 毫秒”（过于技术性，应使用“用户能即时看到结果”）。
- “数据库能处理 1000 TPS”（实现细节，应使用面向用户的指标）。
- “React 组件渲染高效”（框架特定）。
- “Redis 缓存命中率高于 80%”（技术特定）。









